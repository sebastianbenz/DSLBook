\chapter{Debugging DSLs}    

\todo{Do we have a chapter abstract everywhere?}

Debugging is relevant in two ways in the context of DSLs and language
workbenches. First, the DSL developer may want to debug the definition of a DSL,
including constraints, scopes or transformations and interpreters. Second,
programs written in the DSL may have to be debuggable by the end user. We
address both aspects in this chapter.

\section{Debugging the DSL Definition}

\todo{Write something here}

\subsection{Understanding and Debugging the Language Structure}

In parser-based systems, the transformation from text to the AST performed by
the parser\footnote{... and the lexer, if there is one ...} is itself a
non-trivial process and has a potential for errors. Debugging the parsing
process can be important.

\parhead{Xtext} Xtext uses ANTLR\footnote{http://antlr.org} under the hood. In
other words, from the Xtext grammar, an ANTLR grammar is generated which
performs the actual parsing. So understanding and debugging the Xtext parsing
process means understanding and debugging the ANTLR parsing process.

There are two ways to do this. First, since ANTLR generates a Java-based parser,
you can debug the execution of ANTLR (as part of Xtext) itself. Second, you
can have Xtext generate a debug grammar, which contains no action code (so it
does not populate the AST). However, it can be used to debug the parsing process
with ANTLRWorks\footnote{http://www.antlr.org/works}. ANTLRWorks comes with an
interactive debugger for ANTLR grammars.

\parhead{MPS} In MPS there is no transformation from text to the AST since it is
a projectional editor. However, there are still means to help better
understand the structure of an existing program. For example, any program
element can be inspected in the \emph{Explorer}. \fig{mps-explorer} shows the
information for a trivial C function:

\begin{code}
int8_t add(int8_t x, int8_t y) { 
  return x + y; 
} 
\end{code}


\begin{figure}[h]
\begin{center}
  \includegraphics[width=8cm]{figures/8/mps-explorer.png}
  \caption[]{The MPS explorer shows the structure of a program as a tree.
  The explorer also shows the concept for each program element as well as the
  type, if an element has one.}
  \label{mps-explorer} 
\end{center} 
\end{figure}

MPS provides similar support for understanding the projection rules. For any
program node MPS can show the cell structure as a tree. The tree contains
detailed information about the cell hierarchy, the program element associated
with each cell as well as the properties of the cell (height, width, etc.).

\todo{handle the noindent correctly all over the book}

\subsection{Debugging Scopes, Constraints and Type Systems}

Depending on the level of sophistication of a particular language, a lot of
non-trivial behavior can be contained in the code that determines scopes, checks
constraints or computes types. In fact, in many languages, these are the most
sophisticated aspects of language definition. Consequently, there is a need
for debugging those.

\parhead{Xtext} In Xtext, all aspects of a language except the grammar and the
abstract syntax are defined via Java programs using Xtext APIs. This includes
scopes, constraints and type system rules\footnote{It also includes all IDE
aspects.}. Consequently, all these aspects can be debugged by using a Java
debugger. To do this, you can simply launch the Eclipse Application that
contains the language and editor in debug mode and set breakpoints at the
relevant locations\footnote{It is easy to criticize Xtext for the fact that it
does not use DSLs for defining DSLs. However, in the context of debugging this
is good, because no special debuggers are necessary.}.

\parhead{MPS} MPS comes with an equivalent facility in the sense that a second
instance of MPS can be launched that runs "inside" the current one. This inner
instance can be debugged from the outside one. This approach can be used for all
those aspects of MPS-defined languages that are defined in terms of the
BaseLanguage, MPS' version of Java. For example, scopes can be debugged this
way. For example, in \fig{mps-mps-debug} we debug the scope for a
\ic{LocalVariableRef}.


\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/mps-mps-debug.png}
  \caption[]{The debugger that can debug MPS while it "executes" a language is
  aware of all the relevant extensions to BaseLanguage. For example, in this
  screenshot we debug a scope constraint. Notice how in the \ic{Variables} view
  program nodes (such as the \ic{Statement s}) are shown on the abstraction
  level of the node, not in terms of its underlying Java data structure
  representation.}
  \label{mps-mps-debug} 
\end{figure*}


A related feature of MPS is the ability to analyze exception stack traces. MPS
generates Java code from language definitions and then executes this Java code.
If an exception occurs in language implementation code, this exception produces
a Java stack trace. This stack trace can be pasted into a dialog in MPS. MPS
then produces a version of the stack trace where the code locations in the stack
trace (which are relative to the generated Java) have been translated to
locations in the DSL definition (expressed in Base Language). The locations can
be clicked directly, opening the MPS editor at the respective location.

In the design chapter \todo{ref} we discussed how declarative languages may come
with a debugger that fits the particular declarative paradigm used by a
particular declarative language. MPS comes with two facilities. First, pressing
\ic{Ctrl-Shift-T} on any program element will open a dialog that shows the type
of the element. If the element has a type system error, that dialog also lets
the user navigate to the rule that reported the error. The second facility is
much more sophisticated. For any program node, MPS can show the so-called type
system trace (\fig{mps-ts-trace} shows a simple example). Remember how the MPS
type system is relies on a solver to solve the type system equations associated
with program elements (specified by the language developer for the respective
concepts). So each program has an associated set of type system equations.
Those contain explicitly specified types as well as type variables. The solver
tries to find type values for these variables such that all type system
equations become true. The type system trace essentially visualizes the state of
the solver including the values it assigns to type variables as well as which
type system rules are applied to which program element.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/mps-ts-trace.png} 
  \caption[][-20mm]{This
  example shows the solver state for the \ic{Argument x}. It first applies the
  rule \ic{typeof\_ITyped} (\ic{Argument} implements \ic{ITyped}) which
  expresses that the type of the element (type variable
  \ic{c} is the same as the element's \ic{type} property (type variable \ic{d}).
  It then applies the \ic{typeof\_Type} rule to the argument's type itself. This
  rule expresses that the type of a \ic{Type} is a clone of itself.
  Consequently, the type variable \ic{d} can be set to \ic{int8\_t}. In
  consequence this means that the type variable \ic{c} (which represents the
  type of the \ic{Argument}) is also \ic{int8\_t}. Note that this is a trivial
  example. Type system traces can become quite involved.}
  \label{mps-ts-trace} 
\end{figure}


\subsection{Debugging Interpreters and Transformations}

Debugging an interpreter is simple: since an interpreter is just a program
written in some programming language that processes and acts on the DSL program,
debugging the interpreter simply uses the debugger for the language in which the
interpreter is written\footnote{This assumes that the interpreter is written in
a programming language for which a debugger exists}. 

Debugging transformations and generators is typically not quite as trivial, for
two reasons. First, transformations and generators are typically written in DSLs
optimized for this task. So a specialized debugger is required. Second, if
multi-step transformations are used, the intermediate models may have to be
accessible, and it should be possible to trace a particular element through the
multi-step transformation.

\parhead{Xtext} As we have said before, Xtext can be used together with any
EMF-compatible code generator or transformation engine. However, since Xtext
ships with Xtend, we look at debugging Xtend transformations. Model-to-model
transformations and code generators in Xtend look very similar: both use Xtend
to navigate over and query the model, based on the AST. The difference is that,
as a side effect, model-to-model transformations create new model elements and
code generators create strings --- typically using the rich strings (aka
template expressions). 
 
Xtend supports debugging either on the level of the generated code, or on the
Xtend source level. As \fig{templatesdebugging} shows, even the template
expressions can be debugged. The Variables view shows the EMF representation
(i.e. the implementation) of program elements. 
 
\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/xtext-templatesdebugging.png} 
  \caption[][-20mm]{}
  \label{templatesdebugging} 
\end{figure*}

Xtend is a fundamentally an imperative/OO language, so the step-through metaphor
for debuggers is appropriate. If Xtend is used for code generation or
transformation, debugging a boils down to stepping through the code that builds
the target model. I emphasize this because the next example uses a different
appraoch.


\parhead{MPS} In MPS, working with several chained transformations is normal, so
MPS provides support for debugging the transformation process. This support
includes two ingredients. The first one is showing the mapping partitioning. For
a given model, MPS computes the order in which transformations apply and reports
it to the user. This is useful to understand which transformations are executed
in which order\footnote{... and to debug transformation priorities!}. Let us
investigate a simple example C program that contains a message definition and a
\ic{report} statement. The \ic{report} statement is transformed to \ic{printf}
statements.

\begin{code}
module Simple imports nothing { 
   
  message list messages { 
    INFO aMessage() active: something happened 
  } 
   
  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    report(0) messages.aMessage() on/if; 
    return 0; 
  } 
}
\end{code}

Below is the mapping configuration for this program: 

\begin{code}
[ 1 ]
com.mbeddr.core.modules.gen.generator.template.main.removeCommentedCode
[ 2 ]
com.mbeddr.core.util.generator.template.main.reportingPrintf
[ 3 ]
com.mbeddr.core.buildconfig.generator.template.main.desktop
com.mbeddr.core.modules.gen.generator.template.main.main
\end{code}

This particular model is generated in three phases. The first one removes
commented code to make sure it does not show up in the resulting C text file.
The second phase runs the generator that transforms \ic{report} statements into
\ic{printf}s. Finally, the \ic{desktop} generator generates a \ic{make} file
from the build configuration, and the last step generates the C text from the C
tree.

By default, MPS runs all generators until everything is either discarded or
transformed into text. While intermediate models exist, they are not shown to
the user. For debugging purposes though, these intermediate, transient models
can be kept around for inspection. Each of the phases is represented by one or
more transient models. As an example, here is the program after the \ic{report}
statement has been transformed:

\begin{code}
module Simple imports nothing { 

  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    printf("$$ aMessage: something happened "); 
    printf("@ Simple:main:0#240337946125104144 \n "); 
    return 0;
  } 
} 
\end{code}

MPS also supports tracing an element through the intermediate models.
\fig{mps-tracer} shows an example. Users can select a program element in the
source, target or an intermediate model and trace it to the respective other
ends of the transformation.

\begin{figure*}[h]
  \includegraphics[width=18cm]{figures/8/mps-tracer.png}
  \caption[]{The generation trace functionality in MPS allows users to trace
  how a particular program element is transformed through a chain of
  transformations. The generation tracer also shows the transformation rules
  involved in the transformation.}
  \label{mps-tracer} 
\end{figure*}

Note how this approach to debugging transformations is very different from the
Xtend example above: instead of stepping through the transformation
code\footnote{As part of the general Debug-MPS-in-MPS functionality, MPS
transformations can also be debugged in a more imperative fashion. This is
useful, for example, to debug more complex logic used inside transformation
templates.}, MPS provides a \emph{static} representation of the transformation
in terms of the intermediate models and the element traces through them.


\section{Debugging DSL Programs}

To find errors in DSL programs, we can either debug them on the level of the DSL
program or in its $L_{D-1}$ representation (i.e. in the generated code or the
interpreter). Debugging on $L_{D-1}$ is useful if you want to find problems in
the execution engine, or, to some extent, if the language users are programmers
and they have an intimate understanding of the $L_{D-1}$ representation of the
program. However, for many DSLs it is necessary to debug on the level of the DSL
program either because the users are not familiar with the $L_{D-1}$
representation\footnote{This is true particularly for DSLs qtargeted at domain
experts, }, or because the $L_{D-1}$ is so low-level and complex that is bears
no obvious resemblance to the DSL program.


The way to build debuggers for DSLs of course depends on the DSL itself. For
example, for DSLs that only describe structures, debugging does not make much
sense in the first place. For DSLs that describe behavior, the debugging
approach depends on the behavioral paradigm used in the DSL. We have discussed
this in \todo{ref}. In this section we focus mostly on the imperative
paradigm\footnote{An examples for the functional paradigm has been provided in
\todo{ref}, and the type system tracer described above is an example of a
debugger for a declarative language.}.

Building a debugger poses two challenges. The first one is the debugger UI:
creating all the buttons and views for controlling the debugger and for showing
variables and treads. The second challenge concerns the control of and
data exchange with the to-be-debugged program. The first challenge is relatively
simple to solve, since many IDE frameworks (including Eclipse and MPS) already
come with debugger frameworks. 

The second challenge can be a bit more tricky. If the DSL is executed by an
interpreter, the situation is simple: the interpreter can be run and controlled
directly from the debugger. It is easy to implement single-stepping and variable
watches, for example, since the interpreter can directly provide the respective
interfaces\footnote{This is especially true if the interpreter is written in the
same language as the IDE --- no language integration issues have to be addressed
in this case.}. On the other hand, if the DSL program is transformed into code
that is executed in some other environment outside of our control, it may even
be impossible to build a debugger because there is no way to influence and
inspect the running program. Alternatively, it may be necessary to build a
variant of the code generator which generates a \emph{debug version} of the
program which contains specialized code to interact with the debugger. For
example, values of variables may be stored in a special data structure
inspectable by the debugger, and at each program location where the program may
have to stop (in single step mode or as a consequence of a breakpoint) code is
inserted that explicitly suspends the execution of the program, for example by
\ic{sleep}ing the current thread. However, such an approach is often limited and
ugly --- in the end, an execution infrastructure must provide debug support to
enable robust debugging.



\subsection{Print Statements --- a Poor Man's Debugger}

As the above discussion suggests, building full-blown debuggers may be a lot of
work. It is worth exploring whether a simpler approach is good enough. The
simplest such approach is to extend the DSL with language concepts that simply
print interesting aspects of the executing program to the console or a log file.
For example, the values of variables may be output this way.

The mbeddr \ic{report} statement is an example of this approach. A \ic{report}
statement takes a message text plus a set of variables. It then outputs the
message and the values of these variables. The target of the report statement
can be changed. By default, it reports to the console. However, since certain
target devices may not have any console, alternative transformations can be
defined for report statements, that, for example, could output the data to an
error memory or a serial line. A particularly interesting feature of \ic{report}
statements is that the transformation that handles them knows where in the
program the \ic{report} statement is located. It can add this information to the
output\footnote{The go-to-error-location functionality discussed in
\fig{analyzeErrorOutput} is based on this appraoch.}.

An approach based on print \emph{statements} is sometimes clumsy because it
requires factoring out the to-be-printed expression. And it only works for an
imperative language in the first place. For languages that make use of
sophisticated expressions, a different approach is recommended. Consider the
following example:

\begin{code}
Collection[Type] argTypes = aClass.operations.arguments.type;
\end{code}

If you wanted to print the list of operations and arguments, you would have to
change the program to something like this:

\begin{code}
print("operations: " + aClass.operations);
print("arguments: " + aClass.operations.arguments);
Collection[Type] argTypes = aClass.operations.arguments.type;
\end{code}

A much simpler alternative uses \emph{inlined} reporting expressions:


\begin{code}
Collection[Type] argTypes = aClass.operations.print("operations:")
                            .arguments.print("arguments:").type;
\end{code}
 
To make this convenient to use, the \ic{print} function has to return the object
it is called on (the one before the dot), and it must be typed accordingly if a
language with static type checking is used\footnote{The original
openArchitectureWare Xtend did it this way.}.


\subsection{Automatic Program Tracing}

As languages and programs become more complex, an automated tracing of program
execution may be useful. In this approach, all execution steps in a program are
automatically traced and logged into a tree-like data structure. The
refrigerator cooling language uses this approach. Here is an example program:

\begin{code}
cooling program HelloWorld {
    var temp: int
    start:
        entry { state s1 }  
    state s1: 
        check temp < 10 { state s2 }
    state s2: 
}
\end{code} 

Upon startup, it enters the \ic{start} state and immediately transitions to
state \ic{s1}. It remains in \ic{s1} until the variable \ic{temp} becomes less
than 10. It then transitions to \ic{s2}. Below is a test for this program that
verifies this behavior:

\begin{code}
test HelloWorldTest for HelloWorld {
    prolog {
        set temp = 30
    }
    step
    assert-currentstate-is s1
    step
    mock: set temp = 5
    step
    assert-currentstate-is s2
}
\end{code}

\fig{interpreterlog} shows the execution trace. It shows the execution of each
statement and the evaluation of each expression. The log viewer is a table tree
so the various execution steps can be selectively expanded and collapsed. To
connect to the program, users can double-click on an entry to select the
respective program element in the source node. By adding special comments to the
source, the log can be structured further.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/interpreterlog.png}
  \caption[]{The log viewer represents a program's execution as a tree. The
  first column contains a timestamp and the tree nesting structure. The second
  column contains the kind (severity) of the log message. A filter can be used
  to show only messages above a certain severity. The third column shows the
  language concept with which the trace step is associated (double-clicking on
  a row selects this element in the editor). Finally, the last column contains
  the information about the semantic action that was performed in the
  respective step.}
  \label{interpreterlog} 
\end{figure}

The execution engine for the programs is an interpreter, which makes it
particularly simple to collect the trace data. All interpreter methods that
execute statements or evaluate expressions take a \ic{LogEntry} object as an
additional argument. The methods then add children to the current \ic{LogEntry}
that describe whatever the method did, and then passes the child to any other
interpreter methods it calls. As an example, here is the implementation of the
\ic{AssignmentStatement}:

\begin{code}
protected void executeAssignmentStatement(AssignmentStatement s, LogEntry log) {
    LogEntry c = log.child(Kind.info, context, "executing AssignmentStatement" ); 
    Object l = s.getLeft();
    Object r = eval(s.getRight(), c);
    eec().environment.put(symbol, r);
    c.child(Kind.debug, context, "setting " + symbol.getName() + " to " + r);
}
\end{code}

If instead of an interpreter a code generator were used, the same approach could
essentially be used. Instead of embedding the tracing code in the interpreter,
the code generator would generate code that would build the respective trace
data structure in the executing program. Upon termination, the data structure
could be dumped to an XML file and subsequently loaded by the IDE for
inspection.



\subsection{Simulation as an Approximation for Debugging}

The interpreter for the Cooling programs mentioned above is of course not the
final execution engine --- C code is generated that is executed on the actual
target refrigerator hardware. However, as we have discussed in the design part
of the book (\todo{ref}), we can make sure the generated code and the
interpreter are semantically identical by running a sufficient (large) number of
tests. If we do this, we can use the interpreter to test the programs for
logical errors. The interpreter can also be used interactively, in which case it
acts as a simulator for the executing program. \fig{simulator} shows a
screenshot of a running program. 

If you look at \fig{simulator} closely, you will see that it shows all variables
in the program, the events in the queue, running tasks as well as the values of
properties of hardware elements and the current state. It also provides a button
to single-step the program, to run it continuously, and until it hits a
breakpoint. In other words, although the simulator does not use the
familiar\footnote{... familiar to programmers, but not to the target audience!}
UI of a debugger, it actually is a debugger\footnote{As we have said above,
the fact that it runs in the interpreter instead of the generated code is not
a problem if we ensure the two are semantically identical. Of course we cannot
find bugs in the implementation (i.e. in the generator) this way. But to
detect those, debugging on the level of the generated C code is more useful
anyway.}!

If you already have the interpreter\footnote{we discuss how to build on in
\todo{}}, expanding it into a simulator/debugger is relatively simple.
Essentially only three things have to be done:

\begin{itemize}
  \item First, the execution of the program must be controllable from the
  outside. This involves setting breakpoints, single-stepping through the
  program and stopping execution if a breakpoint is hit. In our example case, we
  do not single-step through statements, but only through
  steps\footnote{Remember that the language is time-triggered anyway, so
  execution is basically a sequence of steps triggered by a timer. In the
  simulator/debugger, the timer is replaced with the user pressing the
  \ic{Next Step} button for single stepping.}. Breakpoints are essentially
  Boolean flags associated with program elements: if the
  execution processes a statement that has the \ic{breakpoint} flat set to
  \ic{true}, execution stops.
  \item Second, we have implemented an Observer infrastructure for all parts of
  the program state that should be represented in the simulator UI. Whenever one
  of them changes (as a side effect of executing a statement in the program), an
  event is fired. The UI registers as an observer and updates the UI in
  accordance with the event.
  \item Third, values from the program state must be changeable from the
  outside. As a value in the UI (such as the temperature of a cooling
  compartment) is changed by the user, the value is updated in the state of the
  interpreter as well. 
\end{itemize}


\subsection{Automatic Debugging for Xbase Programs}




\subsection{An Extensible Debugger for an Extensible C}






- Then we hint at how to build a debugger for an Xtext DSL 
and mention that with Xbase, it works automatically.

- then in MPS we discuss mbeddr



Debugger Integration
The MPS debugger has been integrated into IntelliJ IDEA as well. When debugging your Java code you can set breakpoints directly inside the DSL code and so the IntelliJ IDEA debugger will be stopped at the appropriate place allowing you to explore the stack trace and the variables.




Debugging, as the name suggests, is about removing bugs, or errors, from
programs\sidenote{Errors lead to faults, a state of the running program that
leads to a failure, i.e. an externally visible "misbehavior" of the program}.
However, this understanding of the term debugging refers to its \emph{purpose}. From
the perspective of building debuggers, it is more important to look at the
\ic{mechanisms} debuggers use to this end.


The program source is a descriptions of the behavior of a
program. As programmers, we care about the correct behavior, and we have to
write the correct source that leads this behavior. There are two important
differences between the program source and the program behavior:

\begin{itemize}

  \item The program source is a \emph{static} description of the \emph{dynamic}
  behavior of a program.

  \item The program source describes the behavior of the program for \emph{all}
  possible sets of input data, whereas, when a program executes, it always
  executes for a \emph{specific} set of input values.

\end{itemize}

Debugging addresses this discrepancy by allowing programmers to \emph{inspect}
and \emph{animate} the execution of a program for a specific set of input
values. This helps programmers better make the connection between program source
and program execution, and in this way, helps to find errors.

The specific way in which this animation happens depends on the behavioral
paradigm used in the programs: For imperative or object oriented programs, the
well-known step-through metaphor is used. This is mainly because this paradigm
is based on changing (global) state as the program executes, and the debugger
lets users inspect this state and observe it change while stepping through
instructions. 

While this is the most well-known approach to debugging, this is not the only
one. For example, purely functional expressions, which don't change any global
state, can be debugged by showing the values associated with each
sub-expression in a tree. Time-triggered dataflow programs can be debugged by
executing one time step at a time, and showing the values on input and output
pins for each block. 



Xtext: http://www.rcp-vision.com/?p=4089&amp;lang=en

challenge in ext debuggers: paradigms


sys out println (als Programmbefehl oder im Interpreter/Generator) 
log ˆ la BSH
Extensible Debuggers a la mbeddr
automatic debugging ˆ la Xtext/Xbase




debugging the DSL definition (use the debugger of your favourite LWB)
  
debugging the models: only makes sense for models with behavior
state machine debuggers exist
not a lot of support for "getting a debugger for free" from the language definition
problem: debugging on several levels (DSL, intermediate, implemetation), error traceability through the levels
MPS as an example?
 