\chapter{Debugging DSLs}	

\todo{Do we have a chapter abstract everywhere?}

Debugging is relevant in two ways in the context of DSLs and language
workbenches. First, the DSL developer may want to debug the definition of a DSL,
including constraints, scopes or transformations and interpreters. Second,
programs written in the DSL may have to be debuggable by the end user. We
address both aspects in this chapter.

\section{Debugging the DSL Definition}

\todo{Write something here}

\subsection{Understanding and Debugging the Language Structure}

In parser-based systems, the transformation from text to the AST performed by
the parser\footnote{... and the lexer, if there is one ...} is itself a
non-trivial process and has a potential for errors. Debugging the parsing
process can be important.

\parhead{Xtext} Xtext uses ANTLR\footnote{http://antlr.org} under the hood. In
other words, from the Xtext grammar, an ANTLR grammar is generated which
performs the actual parsing. So understanding and debugging the Xtext parsing
process means understanding and debugging the ANTLR parsing process.

There are two ways to do this. First, since ANTLR generates a Java-based parser,
you can debug the execution of ANTLR (as part of Xtext) itself. Second, you
can have Xtext generate a debug grammar, which contains no action code (so it
does not populate the AST). However, it can be used to debug the parsing process
with ANTLRWorks\footnote{http://www.antlr.org/works}. ANTLRWorks comes with an
interactive debugger for ANTLR grammars.

\parhead{MPS} In MPS there is no transformation from text to the AST since it is
a projectional editor. However, there are still means to help better
understand the structure of an existing program. For example, any program
element can be inspected in the \emph{Explorer}. \fig{mps-explorer} shows the
information for a trivial C function:

\begin{code}
int8_t add(int8_t x, int8_t y) { 
  return x + y; 
} 
\end{code}


\begin{figure}[h]
\begin{center}
  \includegraphics[width=8cm]{figures/8/mps-explorer.png}
  \caption[]{The MPS explorer shows the structure of a program as a tree.
  The explorer also shows the concept for each program element as well as the
  type, if an element has one.}
  \label{mps-explorer} 
\end{center} 
\end{figure}

MPS provides similar support for understanding the projection rules. For any
program node MPS can show the cell structure as a tree. The tree contains
detailed information about the cell hierarchy, the program element associated
with each cell as well as the properties of the cell (height, width, etc.).

\todo{handle the noindent correctly all over the book}

\subsection{Debugging Scopes, Constraints and Type Systems}

Depending on the level of sophistication of a particular language, a lot of
non-trivial behavior can be contained in the code that determines scopes, checks
constraints or computes types. In fact, in many languages, these are the most
sophisticated aspects of language definition. Consequently, there is a need
for debugging those.

\parhead{Xtext} In Xtext, all aspects of a language except the grammar and the
abstract syntax are defined via Java programs using Xtext APIs. This includes
scopes, constraints and type system rules\footnote{It also includes all IDE
aspects.}. Consequently, all these aspects can be debugged by using a Java
debugger. To do this, you can simply launch the Eclipse Application that
contains the language and editor in debug mode and set breakpoints at the
relevant locations\footnote{It is easy to criticize Xtext for the fact that it
does not use DSLs for defining DSLs. However, in the context of debugging this
is good, because no special debuggers are necessary.}.

\parhead{MPS} MPS comes with an equivalent facility in the sense that a second
instance of MPS can be launched that runs "inside" the current one. This inner
instance can be debugged from the outside one. This approach can be used for all
those aspects of MPS-defined languages that are defined in terms of the
BaseLanguage, MPS' version of Java. For example, scopes can be debugged this
way. For example, in \fig{mps-mps-debug} we debug the scope for a
\ic{LocalVariableRef}.


\begin{figure*}[h]
  \includegraphics[width=17cm]{figures/8/mps-mps-debug.png}
  \caption[]{The debugger that can debug MPS while it "executes" a language is
  aware of all the relevant extensions to BaseLanguage. For example, in this
  screenshot we debug a scope constraint. Notice how in the \ic{Variables} view
  program nodes (such as the \ic{Statement s}) are shown on the abstraction
  level of the node, not in terms of its underlying Java data structure
  representation.}
  \label{mps-mps-debug} 
\end{figure*}


A related feature of MPS is the ability to analyze exception stack traces. MPS
generates Java code from language definitions and then executes this Java code.
If an exception occurs in language implementation code, this exception produces
a Java stack trace. This stack trace can be pasted into a dialog in MPS. MPS
then produces a version of the stack trace where the code locations in the stack
trace (which are relative to the generated Java) have been translated to
locations in the DSL definition (expressed in Base Language). The locations can
be clicked directly, opening the MPS editor at the respective location.

In the design chapter \todo{ref} we discussed how declarative languages may come
with a debugger that fits the particular declarative paradigm used by a
particular declarative language. MPS comes with two facilities. First, pressing
\ic{Ctrl-Shift-T} on any program element will open a dialog that shows the type
of the element. If the element has a type system error, that dialog also lets
the user navigate to the rule that reported the error. The second facility is
much more sophisticated. For any program node, MPS can show the so-called type
system trace (\fig{mps-ts-trace} shows a simple example). Remember how the MPS
type system is relies on a solver to solve the type system equations associated
with program elements (specified by the language developer for the respective
concepts). So each program has an associated set of type system equations.
Those contain explicitly specified types as well as type variables. The solver
tries to find type values for these variables such that all type system
equations become true. The type system trace essentially visualizes the state of
the solver including the values it assigns to type variables as well as which
type system rules are applied to which program element.

\begin{figure}[h]
  \includegraphics[width=11cm]{figures/8/mps-ts-trace.png} 
  \caption[][-20mm]{This
  example shows the solver state for the \ic{Argument x}. It first applies the
  rule \ic{typeof\_ITyped} (\ic{Argument} implements \ic{ITyped}) which
  expresses that the type of the element (type variable
  \ic{c} is the same as the element's \ic{type} property (type variable \ic{d}).
  It then applies the \ic{typeof\_Type} rule to the argument's type itself. This
  rule expresses that the type of a \ic{Type} is a clone of itself.
  Consequently, the type variable \ic{d} can be set to \ic{int8\_t}. In
  consequence this means that the type variable \ic{c} (which represents the
  type of the \ic{Argument}) is also \ic{int8\_t}. Note that this is a trivial
  example. Type system traces can become quite involved.}
  \label{mps-ts-trace} 
\end{figure}


\subsection{Debugging Interpreters and Transformations}

Debugging an interpreter is simple: since an interpreter is just a program
written in some programming language that processes and acts on the DSL program,
debugging the interpreter simply uses the debugger for the language in which the
interpreter is written\footnote{This assumes that the interpreter is written in
a programming language for which a debugger exists}. 

Debugging transformations and generators is typically not quite as trivial, for
two reasons. First, transformations and generators are typically written in DSLs
optimized for this task. So a specialized debugger is required. Second, if
multi-step transformations are used, the intermediate models may have to be
accessible, and it should be possible to trace a particular element through the
multi-step transformation.

\parhead{Xtext} \todo{Debug an xtend generator and/or a JVMInferrer}

\parhead{MPS} In MPS, working with several chained transformations is normal, so
MPS provides support for debugging the transformation process. This support
includes two ingredients. The first one is showing the mapping partitioning. For
a given model, MPS computes the order in which transformations apply and reports
it to the user. This is useful to understand which transformations are executed
in which order\footnote{... and to debug transformation priorities!}. Let us
investigate a simple example C program that contains a message definition and a
\ic{report} statement. The \ic{report} statement is transformed to \ic{printf}
statements.

\begin{code}
module Simple imports nothing { 
   
  message list messages { 
    INFO aMessage() active: something happened 
  } 
   
  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    report(0) messages.aMessage() on/if; 
    return 0; 
  } 
}
\end{code}

Below is the mapping configuration for this program: 

\begin{code}
[ 1 ]
com.mbeddr.core.modules.gen.generator.template.main.removeCommentedCode
[ 2 ]
com.mbeddr.core.util.generator.template.main.reportingPrintf
[ 3 ]
com.mbeddr.core.buildconfig.generator.template.main.desktop
com.mbeddr.core.modules.gen.generator.template.main.main
\end{code}

This particular model is generated in three phases. The first one removes
commented code to make sure it does not show up in the resulting C text file.
The second phase runs the generator that transforms \ic{report} statements into
\ic{printf}s. Finally, the \ic{desktop} generator generates a \ic{make} file
from the build configuration, and the last step generates the C text from the C
tree.

By default, MPS runs all generators until everything is either discarded or
transformed into text. While intermediate models exist, they are not shown to
the user. For debugging purposes though, these intermediate, transient models
can be kept around for inspection. Each of the phases is represented by one or
more transient models. As an example, here is the program after the \ic{report}
statement has been transformed:

\begin{code}
module Simple imports nothing { 

  exported int32_t main(int32_t argc, int8_t*[] argv) { 
    printf("$$ aMessage: something happened "); 
    printf("@ Simple:main:0#240337946125104144 \n "); 
    return 0;
  } 
} 
\end{code}

MPS also supports tracing an element through the intermediate models.
\fig{mps-tracer} shows an example. Users can select a program element in the
source, target or an intermediate model and trace it to the respective other
ends of the transformation.

\begin{figure*}[h]
  \includegraphics[width=18cm]{figures/8/mps-tracer.png}
  \caption[]{The generation trace functionality in MPS allows users to trace
  how a particular program element is transformed through a chain of
  transformations. The generation tracer also shows the transformation rules
  involved in the transformation.}
  \label{mps-tracer} 
\end{figure*}


\subsection{Debugging DSL Programs}


sys out println (als Programmbefehl oder im Interpreter/Generator) 
log ˆ la BSH
Extensible Debuggers a la mbeddr \label{debug-mps}
automatic debugging ˆ la Xtext/Xbase


Debugger Integration
The MPS debugger has been integrated into IntelliJ IDEA as well. When debugging your Java code you can set breakpoints directly inside the DSL code and so the IntelliJ IDEA debugger will be stopped at the appropriate place allowing you to explore the stack trace and the variables.




Debugging, as the name suggests, is about removing bugs, or errors, from
programs\sidenote{Errors lead to faults, a state of the running program that
leads to a failure, i.e. an externally visible "misbehavior" of the program}.
However, this understanding of the term debugging refers to its \emph{purpose}. From
the perspective of building debuggers, it is more important to look at the
\ic{mechanisms} debuggers use to this end.


The program source is a descriptions of the behavior of a
program. As programmers, we care about the correct behavior, and we have to
write the correct source that leads this behavior. There are two important
differences between the program source and the program behavior:

\begin{itemize}

  \item The program source is a \emph{static} description of the \emph{dynamic}
  behavior of a program.

  \item The program source describes the behavior of the program for \emph{all}
  possible sets of input data, whereas, when a program executes, it always
  executes for a \emph{specific} set of input values.

\end{itemize}

Debugging addresses this discrepancy by allowing programmers to \emph{inspect}
and \emph{animate} the execution of a program for a specific set of input
values. This helps programmers better make the connection between program source
and program execution, and in this way, helps to find errors.

The specific way in which this animation happens depends on the behavioral
paradigm used in the programs: For imperative or object oriented programs, the
well-known step-through metaphor is used. This is mainly because this paradigm
is based on changing (global) state as the program executes, and the debugger
lets users inspect this state and observe it change while stepping through
instructions. 

While this is the most well-known approach to debugging, this is not the only
one. For example, purely functional expressions, which don't change any global
state, can be debugged by showing the values associated with each
sub-expression in a tree. Time-triggered dataflow programs can be debugged by
executing one time step at a time, and showing the values on input and output
pins for each block. 



Xtext: http://www.rcp-vision.com/?p=4089&amp;lang=en

challenge in ext debuggers: paradigms


sys out println (als Programmbefehl oder im Interpreter/Generator) 
log ˆ la BSH
Extensible Debuggers a la mbeddr
automatic debugging ˆ la Xtext/Xbase




debugging the DSL definition (use the debugger of your favourite LWB)
  
debugging the models: only makes sense for models with behavior
state machine debuggers exist
not a lot of support for "getting a debugger for free" from the language definition
problem: debugging on several levels (DSL, intermediate, implemetation), error traceability through the levels
MPS as an example?
 