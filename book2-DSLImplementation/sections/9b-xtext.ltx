\section{Xtext Example}

In this section we look at an example similar to the one for MPS discussed in
the previous section. We start out with a DSL for entities.  Here is an example
program:

\begin{code}
module company {
    entity Employee {
        id : int
        name : string
        role : string
        worksAt : Department
        freelancer : boolean
    }
    entity Department {
        id : int
        description : string
    }
}
\end{code}

The grammar is straight forward and should be clear if you have read the
implementation part so far.

\begin{code}
grammar org.xtext.example.lmrc.entity.EntityDsl with org.eclipse.xtext.common.Terminals

generate entityDsl "http://www.xtext.org/example/lmrc/entity/EntityDsl"

Module:
    "module" name=ID "{"
        entities+=Entity*
    "}";

Entity:
    "entity" name=ID "{"
        attributes+=Attribute*
    "}";

Attribute:
    name=ID ":" type=AbstractType;

Named: Module|Entity|Attribute;

AbstractType:
    BooleanType|IntType|StringType|EntityReference;

BooleanType: {BooleanType} "boolean";

IntType: {IntType} "int";

StringType: {StringType} "string";

EntityReference: ref=[Entity|FQN];

FQN: ID ("." ID)*;
\end{code}


\subsection{Referencing}

Referencing describes the case where programs written in one DSL reference (by
name) program elements written in another DSL, both programs reside in different
fragments and no syntactic composition is required. The example we use is the UI
specification language where a \ic{Form} defined in the UI model refers to
\ic{Entities} from the language defined above, and \ic{Field}s in a form refers
to entity \ic{Attribute}. Here is some example code:

\begin{code}
form CompanyStructure
  uses Department // reference to Department entity
  uses Employee   // reference to Employee entity

field Name: textfield(30)              -> Employee.worksAt
field Role: combobox(Boss, TeamMember) -> Employee.role
field Freelancer: checkbox             -> Employee.freelancer
field Office: textfield(20)            -> Department.description
\end{code}

Note that the references to entities and fields do not technically reference
into an entity source file. Instead, these references refer to the EMF objects
in the AST that has been parsed from the source file. So, a similar approach can
be used to reference to other \ic{EObject}s. It does not matter whether these
are created via Xtext or not. This is reflected by the fact that the grammar of
the \ic{uispec} language does not refer to the \emph{grammar} of the \ic{entity}
language, but to the derived meta model. Here is the header of the \ic{uispec}
language:

\begin{code}
grammar org.xtext.example.lmrc.uispec.UispecDsl with org.eclipse.xtext.common.Terminals

import "http://www.xtext.org/example/lmrc/entity/EntityDsl" as entity

generate uispecDsl "http://www.xtext.org/example/lmrc/uispec/UispecDsl"
\end{code}

Importing a meta model means that the respective \emph{meta classes} can now be
used. Note that the meta model import does not make the \emph{grammar rules}
visilble, so the meta classes can only be used in references and as base types
(as we will see later). In case of referencing, we use them in references:

\begin{code}
EntityReference:
    "uses" entity=[entity::Entity|FQN];

Field:
    "field" label=ID ":" widget=Widget "->" attribute=[entity::Attribute|FQN];
\end{code}

To make this work, no change is required in the \ic{entities} language as long
as the target elements are in the index. The index is used by Xtext to resolve
references against elements that reside in a different model file. By default,
all elements that have a \ic{name} attribute are in the index. \ic{Entity} and
\ic{Attribute} have names, so this works automatically. To make the referencing
work, the workflow generarting the \ic{uispec} language has to be changed as
well. The \ic{genmodel} file for the meta model has to be registered in the
\ic{StandaloneSetup}\sidenote{This is necessary so that the EMF code
generator, when generating the meta classes for the \ic{uispec} language knows
where the generated Java classes for the \ic{entities} languages reside. This
is an EMF technicality and we won't discuss it in any more detail}.

\begin{code}
bean = StandaloneSetup {
    ...
    registerGenModelFile = "platform:/resource/org.xtext.example.lmrc.entity/
                src-gen/org/xtext/example/lmrc/entity/EntityDsl.genmodel"
}
\end{code}

We have to do one more customization to make the language work smoothly. The
only \ic{Attribute}s that should be visible are those from the entities
referenced in the current \ic{Form}'s \ic{uses} clauses, and they should be
referenced with a qualified name (\ic{Employee.role} instead of just \ic{role}).
Scoping has to be customized to achieve this:

\begin{code}
public IScope scope_Field_attribute(Field context, EReference ref) {
    Form form = EcoreUtil2.getContainerOfType(context, Form.class);
    List<Attribute> visibleAttributes = new ArrayList<Attribute>();
    for (EntityReference useClause : form.getUsedEntities()) {
        visibleAttributes.addAll(useClause.getEntity().getAttributes());
    }
    Function<Attribute, QualifiedName> nameComputation = new Function<Attribute, QualifiedName>() {
        @Override
        public QualifiedName apply(Attribute a) {
            return QualifiedName.create(((Entity)a.eContainer()).getName(), a.getName());
        }
    };
    return Scopes.scopeFor(visibleAttributes, nameComputation , IScope.NULLSCOPE);
}
\end{code}

This scoping function performs two tasks: first, it finds all the
\ic{Attribute}s of all \ic{used} entities. We collect them into a list
\ic{visibleAttributes}. The second part of the scoping function defines a
\ic{Function} object\sidenote{Note how we have to use the ugly function object
notation, because Java does not provide support for closures or lambdas at this
point!} that represents a function from \ic{Attribute} to \ic{QualifiedName}. In
the implementation method \ic{apply} we create a qualified name made from two
parts: the entity name and the attribute name (the dot between the two is
default behavior for the \ic{QualifiedName} class). When we create the scope
itself in the last line we pass in the list of attributes as well as the
function object. Xtext's scoping framework uses the function object to determine
the name by which each of the attributes is referencable from this particular
context.

\todo{In the whole chapter: discuss type systems and generators}

\subsection{Reuse}

Referencing concerns the case where the referencing language is built with the
knowledge about the referenced language, so it can have direct dependencies. In
the example above, the \ic{uispec} language uses \ic{Entity}
and \ic{Attribute} from the \ic{entities} language. It directly imports the meta
model, so it has a direct dependency.

In case of reuse, such a direct dependency is not allowed. Our goal is to
combine two \emph{independent} languages. To show this case, we again use the
same example as in the MPS section. We first introduce a \ic{db} language. It is
a trivial DSL for defining relational table structures. These can optionally be
mapped to a data source, but the language makes no assumption about how this
data source looks (and which language is used to define it). Consequently, the
grammar has no dependency on another other one, and imports no other meta model:

\begin{code}
grammar org.xtext.example.lmrc.db.DbDsl with org.eclipse.xtext.common.Terminals
generate dbDsl "http://www.xtext.org/example/lmrc/db/DbDsl"

Root:
      Database;

Database:
    "database" name=ID
    tables+=Table*;
    
Table:
    "table" name=ID
    columns+=Column*    ;
    
Column:
    type=AbstractDataType name=ID (mapper=AbstractColumnMapper)?;

AbstractColumnMapper: {AbstractColumnMapper}"not mapped";

AbstractDataType: 
    CharType | NumberType;

CharType: {CharType}"char";

NumberType: {NumberType}"number";        
\end{code}

The \ic{Column} rule has an optional \ic{mapper} property of type
\ic{AbstractColumnMapper}. Since it is not possible to explicitly mark rules as
generating astract meta classes, we simply define the syntax to be "not mapped". 
This language has been designed \emph{for} reuse, because it has this hook
\ic{AbstractColumnMapper}, which can be customized later. But the language is
still independent. In the next step, we want to be able to reference
\ic{Attribute}s from the entities language:

\begin{code}
database CompanyDB

table Departments
  number id          <- Department.id
  char descr         <- Department.description
  
table People
  number id          <- Employee.id
  char name          <- Employee.name
  char role          <- Employee.role
  char isFreelancer  <- Employee.freelancer
\end{code}

To make this possible, we create a new language \ic{db2entity} which \emph{extends} the
\ic{db} language and \emph{references} the \ic{entities} language. This is
reflected by the header of the \ic{db2entity} language (notice the \ic{with}
clause):

\begin{code}
grammar org.xtext.example.lmrc.db2entity.Db2EntityDsl with org.xtext.example.lmrc.db.DbDsl

import "http://www.xtext.org/example/lmrc/db/DbDsl" as db
import "http://www.xtext.org/example/lmrc/entity/EntityDsl" as entity

generate db2EntityDsl "http://www.xtext.org/example/lmrc/db2entity/Db2EntityDsl"
\end{code}

We now have to overwrite the \ic{AbstractColumnMapper} rule defined in the
\ic{db} language. 

\begin{code}
AbstractColumnMapper returns db::AbstractColumnMapper:
    {EntityColumnMapper} "<-" entity=[entity::Attribute|FQN];
\end{code}

We create a rule that has the same name as the rule in the super-grammar. So
when the new grammar calls the \ic{AbstractColumnMapper} rule, our new
definition is used. Inside, we define the new syntax we would like to use, and
as part of it, we reference an \ic{Attribute} from the imported \ic{entity} meta
model. We then use the \ic{\{EntityColumnMapper\}} action to force instantiation
of an \ic{EntityColumnMapper} object: this also implicitly leads to the creation
of an \ic{EntityColumnMapper} class in the generated \ic{db2entity} meta model.
Since our new rule \ic{returns} an \ic{db::AbstractColumnMapper}, this new meta
class extends \ic{AbstractColumnMapper} from the \ic{db} meta model --- which is
exactly what we want.

There are two more things we have to do to make it work. First, we have to
register the two \ic{genmodel} files in the \ic{db2entity}'s
\ic{StandaloneSetup} bean in the workflow file. Second, we have to address the
fact that in Xtext, the first rule in a grammar file is the entry rule for the
grammar, i.e. the parser starts consuming a model file using this rule. In our
\ic{db2entity} grammar, the first rule is \ic{AbstractColumnMapper}, so this
won't work. We have to add the real root, which is simply the same one as in the
\ic{db} language:

\begin{code}
Root returns db::Root :
    Database;
\end{code}



\subsection{Extension}

We have already seen the mechanics of extension in the previous example, since,
as a way of building the reuse infrastructure, we have extended the \ic{db}
language. In this section we look at extension in more detail. Extension is
defined as syntactic integration with explicit dependencies. However, there are
two use cases that feel different:

\begin{enumerate}
  \item In one case we provide (small scale) additional syntax to an otherwise
  unchanged language. The \ic{db2entity} language shown above is an example of
  this. The \ic{db2entity} programs look essentially like programs written in
  the \ic{db} base language, but in one (or few) particular places, something is
  different. In the example, the syntax for referencing attributes is such as
  small scale change.
  \item The other case is where we create a completely new language, but reuse
  some of the syntax provided by the base language. This use case \emph{feels}
  like embedding (we embed syntax from the base language in our new language),
  but in the classification according to syntactic integration and dependencies,
  it is still extension. Embedding would prevent explicit dependencies. In this
  section we look at extension with an embedding flavor.
\end{enumerate}

To illustrate extension-with-embedding-flavor, we will show how to embed XBase
expressions in a custom DSL. XBase is a reusable expression language that ships
with Xtext. It provides primitive types, various unary and binary operators,
functions and closures. As we will see it is very tightly integrated with
Java\sidenote{This is a mixed blessing. As long as you stay in a JVM world (use
Java types, generate Java code), it means that many things are very simple.
However, as soon as you go outside of the JVM world, a lot of things become
quite complex and it is questionable whether using Xbase makes sense in this
case at all.}. As an example, we essentially create another entity language;
thanks to Xbase, we will be able to write:

\begin{code}
module sample {
    entity Person {
        lastname : String
        firstname : String
        String fullName(String from) {
            return "Hello " + firstname + " "  + lastname + " from " + from
        }
    }
}
\end{code}

Here is the essential part of the grammar. Note how it extends the Xbase grammar
(\ic{with} clause) and how it uses various elements from Xbase throughout the
code (those whose names start with an \ic{X}).

\begin{code}
grammar org.xtext.example.lmrc.entityexpr.EntityWithExprDsl with org.eclipse.xtext.xbase.Xbase

generate entityWithExprDsl "http://www.xtext.org/example/lmrc/entityexpr/EntityWithExprDsl"

Module:
    "module" name=ID "{"
        entities+=Entity*
    "}";

Entity:
    "entity" name=ID "{"
        attributes+=Attribute*
        operations+=Operation*
    "}";

Attribute:
    name=ID ":" type=JvmTypeReference;

Operation:
    type=JvmTypeReference name=ID "("  (parameters+=FullJvmFormalParameter (',' parameters+=FullJvmFormalParameter)*)? ")"
        body=XBlockExpression;
\end{code}

Let's look at some of the details. First, the types (of the \ic{Attribute}
and the \ic{Operation}) are not defined by our grammar, instead we use a
\ic{JvmTypeReference}. This makes all Java types legal in this place. Limiting
this to the primitive types (or some subset) requires a scoping rule. On the
other hand, one can automatically use any valid Java type here. We use an
\ic{XBlockExpression} as the body of \ic{Operation}, which essentially allows us
to use the full Xbase programming language inside the body of the
\ic{Operation}. To make the \ic{parameters} visible, we use the
\ic{FullJvmFormalParameter} rule.

Above I wrote that Xbase is tightly integrated with the JVM and Java. The use of 
\ic{FullJvmFormalParameter} and \ic{JvmTypeReference} is a sign of this.
However, the next piece of code makes this even clearer. The
\ic{JvmModelInferrer} maps the model to structurally equivalent Java code. By
doing this, we get a number of benefits "for free", including scoping, typing
and a code generator. Let us look at this crucial step in some detail.

\begin{code}
class EntityWithExprDslJvmModelInferrer extends AbstractModelInferrer {
    
    @Inject extension IQualifiedNameProvider
    @Inject extension JvmTypesBuilder
    
    def dispatch void infer(Entity entity, 
                            IAcceptor<JvmDeclaredType> acceptor, 
                            boolean isPrelinkingPhase) {
        ...    
    }
}    
\end{code}

This Xtend class implements a method \ic{infer} that creates the structurally
equivalent Java code as an EMF tree and registers it with the \ic{acceptor}. The
method is marked as \ic{dispatch}, so it can be polymorphically overwritten for
various types. We override it for the \ic{Entity} type. We also have the
\ic{IQualifiedNameProvider} provider and \ic{JvmTypesBuilder} injected. The
latter contains a builder API for creating all kinds JVM objects, such as
fields, setters, classes or operations.

\begin{code}
acceptor.accept(
    entity.toClass( entity.fullyQualifiedName ) [
        documentation = entity.documentation
        ...
    ]
)
\end{code}

At the top level, we map the \ic{Entity} to a \ic{Class}. \ic{toClass} is one of
these builder methods defined in the \ic{JvmTypesBuilder}. The class we create
should have the same name as the \ic{entity}; the name of the class is passed in
the constructor. The second argument, written conveniently behind the
parentheses, is a closure. Inside the closure, there is a variable \ic{it} that
refers to the target element (the class in this case). It is possible to omit
the \ic{it}, so when we write \ic{documentation = ...} this actually means
\ic{it.documentation = ...}. In other words, we set the documentation of the
created class to be the documentation of the \ic{entity}. Next we create a
field, a getter and a setter for each of the attributes of the
\ic{Entity}.  

\begin{code}
for ( attr : entity.attributes ) {
    members += attr.toField(attr.name, attr.type)
    members += attr.toGetter(attr.name, attr.type)
    members += attr.toSetter(attr.name, attr.type)
}
\end{code}

\ic{toField}, \ic{toGetter} and \ic{toSetter} are all builders contributed by
the \ic{JvmTypesBuilder}. Let us better understand what they do. Here is the
implementation of \ic{toSetter}. Note that the first argument supplied by the
object in front of the dot, i.e. the \ic{Attribute}. 

\begin{code}
public JvmOperation toSetter(EObject sourceElement, final String name, JvmTypeReference typeRef) {
    JvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();
    result.setVisibility(JvmVisibility.PUBLIC);
    result.setSimpleName("set" + nullSaveName(Strings.toFirstUpper(name)));
    result.getParameters().add(toParameter(sourceElement, nullSaveName(name), cloneWithProxies(typeRef)));
    if (name != null) {
        setBody(result, new Functions.Function1<ImportManager, CharSequence>() {
            public CharSequence apply(ImportManager p) {
                return "this." + name + " = " + name + ";";
            }
        });
    }
    return associate(sourceElement, result);
}
\end{code}

The method first creates a \ic{JvmOperation} and sets the visibility and the
name. It then creates a parameter that uses the type passed in as the third
argument as its type. As you can see, all of this happens via model-to-model
transformation. This is important, because these created objects are used
implicitly in scoping and typing. The body, however, is created textually; it is
not needed for type scoping or typing, it is used only in code generation. Since
that is a to-text transformation anyway, it is good enough to represent the body
of the setter as text already at this level. The last line is important: it
associates the source element (the \ic{Attribute} in our case) with the created
element (the setter \ic{Operation} we just created). As a consequence of
this association, the Xbase scoping and typing framework can work its magic of
providing support for our DSL without any further customization!

Let us now continue our look a the implementation of the \ic{JvmModelInferrer}
for the \ic{Entity}. The last step before our detour was that we created fields,
setters and getters for all attributes of our \ic{Entity}. We have to deal with
the operations of our \ic{Entity} next. 

\begin{code}
for ( op : entity.operations ) {
    members += op.toMethod(op.name, op.type) [
        for (p : op.parameters) {
            parameters += p.toParameter(p.name, p.parameterType)
        }
        body = op.body
    ]
}
\end{code}

This code should be easy to understand. We create a method for each operation
using the respective builder method, pass in the name and type, create a
parameter for each of the parameters of our source operation and then assign the
body of the created method to be the body of the operation in our DSL program.
The last step is particularly important. Notice that we don't clone the body, we
assign the object directly. Looking into the \ic{setBody} method (the
assignment is actually mapped to a setter in Xtend), we see the following:

\begin{code}
public void setBody(JvmExecutable logicalContainer, XExpression expr) {
    if (expr == null)
        return;
    associator.associateLogicalContainer(expr, logicalContainer);
}
\end{code}

The \ic{associateLogicalContainer} method is what makes the automatic support
for scoping and typing happen:

\begin{itemize}
  \item because the operation is the container of the expression, the
  expression's type and the operartion's type must be compatible
  \item because the expression(s) live inside the operation, the parameters of
  the operation, as well as the current class's fields, setters and getters are
  in scope automatically.
\end{itemize}

\todo{Can we show how the generator would work here?}

This approach of mapping a DSL to Java "code" via this model transformation
works nicely as long as it maps to Java code in a simple way. In the above case
of entities, the mapping is trivial and obvious. If the semantic gap becomes
bigger, the \ic{JvmTypeInferrer} becomes more complicated. However, what is
really nice is this: within the type inferrer, you can of course use Xtend's
template syntax (discussed in \todo) to create implementation code. So it is
easy to mix model transformation (for those parts of a mapping that is relevant
to scoping and type calculation) and then use traditional to-text transformation
using Xtend's powerful template syntax for the detailed implementation aspects.

\todo{Describe what you have to touch if it does not fit with Java}

\todo{What does one have to do *extend* Xbase, e.g. by providing an additional
expression?}

\todo{We should also discuss generator modularization with DI}


% \subsection{Referencing}
% 
% GuiDSL -> Entity DSL
% 
% ResourceServiceProvider: Referenzieren von "nicht Xtext, aber EMF" Artekfakten
% 
% 
% \subsection{Extension}
%  
% die Entity DSL von Xbase erben lassen und die Expressions einbauen
% dabei: einführen von JVMElement in Eneitty DSL damit bspw. ENtity Attribute 
% aus Expressns referenzierbar sind (Expressions bspw. beo derived entity
% attributes)
% 
% Sagen dass alles so funkt wie in Java - so lange man sich da dran hält ist alles
% gut, wenn man aus dieser box raus will wirds schnell anstrengend
% 
% 
% \subsection{Reuse}
% 
% Persoistence DSL die "abstrakt" auf Datenstrukturen referenziert,
% die ADapter, Untersrprache fügt die konkreten Referenzen etc. hinzu auf unsere
% Entity Sprache.
% 
% \subsection{Embedding}
% 
% Geht net, weil man nicht von 2 Spachen erben kann.
% Copy & paste als alternative
% 
% Aber, klar: syntaktisches einbetten geht durch vererbung, aber nicht unter
% beibehaltung der Unabhängigkeit der Sprachen --- damit structly speaking kein
% Embedding, sondern Extension "mit Embedding FLavor"
% Extension etwender
% - "einbetten" von expressions der oberspache in "meine" untersprache
% - Neue "top level" DInge hinzufügen
% 
% Als Beispiel warum: Unab. SQL und Java einbetten