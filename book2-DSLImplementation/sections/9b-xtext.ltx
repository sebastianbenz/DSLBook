\section{Xtext Example}

In this section we look at an example similar to the one for MPS discussed in
the previous section. We start out with a DSL for entities.  Here is an example
program:

\begin{code}
module company {
    entity Employee {
        id : int
        name : string
        role : string
        worksAt : Department
        freelancer : boolean
    }
    entity Department {
        id : int
        description : string
    }
}
\end{code}

The grammar is straight forward and should be clear if you have read the
implementation part so far.

\begin{code}
grammar org.xtext.example.lmrc.entity.EntityDsl with org.eclipse.xtext.common.Terminals

generate entityDsl "http://www.xtext.org/example/lmrc/entity/EntityDsl"

Module:
    "module" name=ID "{"
        entities+=Entity*
    "}";

Entity:
    "entity" name=ID "{"
        attributes+=Attribute*
    "}";

Attribute:
    name=ID ":" type=AbstractType;

Named: Module|Entity|Attribute;

AbstractType:
    BooleanType|IntType|StringType|EntityReference;

BooleanType: {BooleanType} "boolean";

IntType: {IntType} "int";

StringType: {StringType} "string";

EntityReference: ref=[Entity|FQN];

FQN: ID ("." ID)*;
\end{code}


\subsection{Referencing}

Referencing describes the case where programs written in one DSL reference (by
name) program elements written in another DSL, both programs reside in different
fragments and no syntactic composition is required. The example we use is the UI
specification language where a \ic{Form} defined in the UI model refers to
\ic{Entities} from the language defined above, and \ic{Field}s in a form refers
to entity \ic{Attribute}. Here is some example code:

\begin{code}
form CompanyStructure
  uses Department // reference to Department entity
  uses Employee   // reference to Employee entity

field Name: textfield(30)              -> Employee.worksAt
field Role: combobox(Boss, TeamMember) -> Employee.role
field Freelancer: checkbox             -> Employee.freelancer
field Office: textfield(20)            -> Department.description
\end{code}

Note that the references to entities and fields do not technically reference
into an entity source file. Instead, these references refer to the EMF objects
in the AST that has been parsed from the source file. So, a similar approach can
be used to reference to other \ic{EObject}s. It does not matter whether these
are created via Xtext or not. This is reflected by the fact that the grammar of
the \ic{uispec} language does not refer to the \emph{grammar} of the \ic{entity}
language, but to the derived meta model. Here is the header of the \ic{uispec}
language:

\begin{code}
grammar org.xtext.example.lmrc.uispec.UispecDsl with org.eclipse.xtext.common.Terminals

import "http://www.xtext.org/example/lmrc/entity/EntityDsl" as entity

generate uispecDsl "http://www.xtext.org/example/lmrc/uispec/UispecDsl"
\end{code}

Importing a meta model means that the respective \emph{meta classes} can now be
used. Note that the meta model import does not make the \emph{grammar rules}
visilble, so the meta classes can only be used in references and as base types
(as we will see later). In case of referencing, we use them in references:

\begin{code}
EntityReference:
    "uses" entity=[entity::Entity|FQN];

Field:
    "field" label=ID ":" widget=Widget "->" attribute=[entity::Attribute|FQN];
\end{code}

To make this work, no change is required in the \ic{entities} language as long
as the target elements are in the index. The index is used by Xtext to resolve
references against elements that reside in a different model file. By default,
all elements that have a \ic{name} attribute are in the index. \ic{Entity} and
\ic{Attribute} have names, so this works automatically. To make the referencing
work, the workflow generarting the \ic{uispec} language has to be changed as
well. The \ic{genmodel} file for the meta model has to be registered in the
\ic{StandaloneSetup}\sidenote{This is necessary so that the EMF code
generator, when generating the meta classes for the \ic{uispec} language knows
where the generated Java classes for the \ic{entities} languages reside. This
is an EMF technicality and we won't discuss it in any more detail}.

\begin{code}
bean = StandaloneSetup {
    ...
    registerGenModelFile = "platform:/resource/org.xtext.example.lmrc.entity/
                src-gen/org/xtext/example/lmrc/entity/EntityDsl.genmodel"
}
\end{code}

We have to do one more customization to make the language work smoothly. The
only \ic{Attribute}s that should be visible are those from the entities
referenced in the current \ic{Form}'s \ic{uses} clauses, and they should be
referenced with a qualified name (\ic{Employee.role} instead of just \ic{role}).
Scoping has to be customized to achieve this:

\begin{code}
public IScope scope_Field_attribute(Field context, EReference ref) {
    Form form = EcoreUtil2.getContainerOfType(context, Form.class);
    List<Attribute> visibleAttributes = new ArrayList<Attribute>();
    for (EntityReference useClause : form.getUsedEntities()) {
        visibleAttributes.addAll(useClause.getEntity().getAttributes());
    }
    Function<Attribute, QualifiedName> nameComputation = new Function<Attribute, QualifiedName>() {
        @Override
        public QualifiedName apply(Attribute a) {
            return QualifiedName.create(((Entity)a.eContainer()).getName(), a.getName());
        }
    };
    return Scopes.scopeFor(visibleAttributes, nameComputation , IScope.NULLSCOPE);
}
\end{code}

This scoping function performs two tasks: first, it finds all the
\ic{Attribute}s of all \ic{used} entities. We collect them into a list
\ic{visibleAttributes}. The second part of the scoping function defines a
\ic{Function} object\sidenote{Note how we have to use the ugly function object
notation, because Java does not provide support for closures or lambdas at this
point!} that represents a function from \ic{Attribute} to \ic{QualifiedName}. In
the implementation method \ic{apply} we create a qualified name made from two
parts: the entity name and the attribute name (the dot between the two is
default behavior for the \ic{QualifiedName} class). When we create the scope
itself in the last line we pass in the list of attributes as well as the
function object. Xtext's scoping framework uses the function object to determine
the name by which each of the attributes is referencable from this particular
context.

\todo{In the whole chapter: discuss type systems and generators}

\subsection{Reuse}

Referencing concerns the case where the referencing language is built with the
knowledge about the referenced language, so it can have direct dependencies. In
the example above, the \ic{uispec} language uses \ic{Entity}
and \ic{Attribute} from the \ic{entities} language. It directly imports the meta
model, so it has a direct dependency.

In case of reuse, such a direct dependency is not allowed. Our goal is to
combine two \emph{independent} languages. To show this case, we again use the
same example as in the MPS section. We first introduce a \ic{db} language. It is
a trivial DSL for defining relational table structures. These can optionally be
mapped to a data source, but the language makes no assumption about how this
data source looks (and which language is used to define it). Consequently, the
grammar has no dependency on another other one, and imports no other meta model:

\begin{code}
grammar org.xtext.example.lmrc.db.DbDsl with org.eclipse.xtext.common.Terminals
generate dbDsl "http://www.xtext.org/example/lmrc/db/DbDsl"

Root:
  	Database;

Database:
	"database" name=ID
	tables+=Table*;
	
Table:
	"table" name=ID
	columns+=Column*	;
	
Column:
	type=AbstractDataType name=ID (mapper=AbstractColumnMapper)?;

AbstractColumnMapper: {AbstractColumnMapper}"not mapped";

AbstractDataType: 
	CharType | NumberType;

CharType: {CharType}"char";

NumberType: {NumberType}"number";		
\end{code}

The \ic{Column} rule has an optional \ic{mapper} property of type
\ic{AbstractColumnMapper}. Since it is not possible to explicitly mark rules as
generating astract meta classes, we simply define the syntax to be "not mapped". 
This language has been designed \emph{for} reuse, because it has this hook
\ic{AbstractColumnMapper}, which can be customized later. But the language is
still independent. In the next step, we want to be able to reference
\ic{Attribute}s from the entities language:

\begin{code}
database CompanyDB

table Departments
  number id          <- Department.id
  char descr         <- Department.description
  
table People
  number id          <- Employee.id
  char name          <- Employee.name
  char role          <- Employee.role
  char isFreelancer  <- Employee.freelancer
\end{code}

To make this possible, we create a new language \ic{db2entity} which \emph{extends} the
\ic{db} language and \emph{references} the \ic{entities} language. This is
reflected by the header of the \ic{db2entity} language (notice the \ic{with}
clause):

\begin{code}
grammar org.xtext.example.lmrc.db2entity.Db2EntityDsl with org.xtext.example.lmrc.db.DbDsl

import "http://www.xtext.org/example/lmrc/db/DbDsl" as db
import "http://www.xtext.org/example/lmrc/entity/EntityDsl" as entity

generate db2EntityDsl "http://www.xtext.org/example/lmrc/db2entity/Db2EntityDsl"
\end{code}

We now have to overwrite the \ic{AbstractColumnMapper} rule defined in the
\ic{db} language. 

\begin{code}
AbstractColumnMapper returns db::AbstractColumnMapper:
	{EntityColumnMapper} "<-" entity=[entity::Attribute|FQN];
\end{code}

We create a rule that has the same name as the rule in the super-grammar. So
when the new grammar calls the \ic{AbstractColumnMapper} rule, our new
definition is used. Inside, we define the new syntax we would like to use, and
as part of it, we reference an \ic{Attribute} from the imported \ic{entity} meta
model. We then use the \ic{\{EntityColumnMapper\}} action to force instantiation
of an \ic{EntityColumnMapper} object: this also implicitly leads to the creation
of an \ic{EntityColumnMapper} class in the generated \ic{db2entity} meta model.
Since our new rule \ic{returns} an \ic{db::AbstractColumnMapper}, this new meta
class extends \ic{AbstractColumnMapper} from the \ic{db} meta model --- which is
exactly what we want.

There are two more things we have to do to make it work. First, we have to
register the two \ic{genmodel} files in the \ic{db2entity}'s
\ic{StandaloneSetup} bean in the workflow file. Second, we have to address the
fact that in Xtext, the first rule in a grammar file is the entry rule for the
grammar, i.e. the parser starts consuming a model file using this rule. In our
\ic{db2entity} grammar, the first rule is \ic{AbstractColumnMapper}, so this
won't work. We have to add the real root, which is simply the same one as in the
\ic{db} language:

\begin{code}
Root returns db::Root :
	Database;
\end{code}



\subsection{Extension}





% \subsection{Referencing}
% 
% GuiDSL -> Entity DSL
% 
% ResourceServiceProvider: Referenzieren von "nicht Xtext, aber EMF" Artekfakten
% 
% 
% \subsection{Extension}
%  
% die Entity DSL von Xbase erben lassen und die Expressions einbauen
% dabei: einführen von JVMElement in Eneitty DSL damit bspw. ENtity Attribute 
% aus Expressns referenzierbar sind (Expressions bspw. beo derived entity
% attributes)
% 
% Sagen dass alles so funkt wie in Java - so lange man sich da dran hält ist alles
% gut, wenn man aus dieser box raus will wirds schnell anstrengend
% 
% 
% \subsection{Reuse}
% 
% Persoistence DSL die "abstrakt" auf Datenstrukturen referenziert,
% die ADapter, Untersrprache fügt die konkreten Referenzen etc. hinzu auf unsere
% Entity Sprache.
% 
% \subsection{Embedding}
% 
% Geht net, weil man nicht von 2 Spachen erben kann.
% Copy & paste als alternative
% 
% Aber, klar: syntaktisches einbetten geht durch vererbung, aber nicht unter
% beibehaltung der Unabhängigkeit der Sprachen --- damit structly speaking kein
% Embedding, sondern Extension "mit Embedding FLavor"
% Extension etwender
% - "einbetten" von expressions der oberspache in "meine" untersprache
% - Neue "top level" DInge hinzufügen
% 
% Als Beispiel warum: Unab. SQL und Java einbetten