Design
----------------------------------------------------------
Case Studies: Jan Visualisierung, ISC Achmea, Spray, Youtrack Team? 

Checking constraints, different cost, at different times.

what about dimensions like:
static analyzability, users training/maturity, integration with existing software ? 

Expressivity:
John C. Mitchell, "On abstraction and the expressive power of programming languages", Science of Computer Programming, 1993
Matthias Felleisen, On the expressive power of programming languages,  Science of Computer Programming, 1991

Do we want to remove the formulas? Or at least provide examples for each?

Du könntest noch etwas in Richtung Freiheitsgrade unterbringen. Mit DSLs schränkt man von die (fast) unendliche Freiheit auf wenige Ausdrucksmöglichkeiten ein, dafür bekommt man leichtere Erlernbarkeit, weniger Fehleranfälligkeit, bessere Optimierbarkeit usw. Würde in den 2. Absatz passen.

Bei Expressivity: nochmal klar sagen dass auch Wissen über die Domäne im 
Generator/EE steckt. Hört sich so an, als ob viel Code gut wäre. Dabei ist es doch so, dass man in einer reife Domäne so viel Semantik in ein oder wenige Elemente packen kann, dass man in einer GPL enorm viel Code bräuchte, um dieselbe Semantik auszudrücken. Dafür kann man sonst nix ausdrücken, hat also keine Flexibilität mehr. (Für mich sind DSLs ja nur dafür da, um die übrig gebliebene Variabilität zu binden.) Die Semantik, die unveränderlich ist für alle Instanzen eines Sprachelements kann fest vor-codiert werden, nur die Variabilität muss noch in der DSL tatsächlich ausgedrückt werden. 
Fällt Dir eine gute Art und Weise ein zu beschreiben, wie durch Beschränkung und Abstraktion eine kleinere Sprache entsteht? 
-> Var, Immer gleich


bei Semantik: nochmal zusammenhang zwischen Domäne, der Variabilität da drin,
der DSL und dem Generaotr zeigen.

PLE: 
1) kompakte DSL, kleine Variantenprogramme, jedes Mal neuschreiben
2) Sprache ist orthogonal zu drübergelefter pos oder neg Var
3) DSL kann Var direkt ausdrücken (durch Komponenten, Schnittstellen, Vererbung)
4) ggfs. User Defined ABstractions erlauben, damit nicht für jede Var 
   die Sprache geändert werden muss
   
Im Designkapitel:
Am Anfang: Anspruch; was ist es, was ist es nciht (komplette Methode)
Die bedeutung von Erfahrung


Sep of Concerns: 
Cross-Cutting Concerns?

Update all mbeddr Screenshots in intro and Design chapter

In the modularization part: we seem to need more examples (especially in the
transformation etc.). But these will come in the implementation chapter as well.


Implementation
----------------------------------------------------------
Checking constraints, different cost, at different times.
Synchronization via auto-running quick fixes.

Formale Methoden: Generiere TestfŠlle vom Modell automatisch; dann generiere
diese in die Zielwelt (codegen, interpreter) and run them.

testen von ausfŸhrbarem code: testet nicht, was neben *auch noch* geht...
... zusŠtzlich zu dem was gehen soll. (security)

IDE services: pretty printers, analyzers, debuggers, ...






General
------------------------------------------------------------
Clean up "I" and "we".
Einige der "I"s in passiv wandeln
Our

